#!/usr/bin/env python
#
# generate_points.py
#
# Generate some integral points in a given bounding box and write them to
# stdout.
#

import os
import sys
import time
import random
import itertools as it
import math
from operator import itemgetter
import argparse
import traceback

import shapefile

if sys.version_info.major > 2:
    xrange = range

_shapefile_major_version = int(shapefile.__version__.split('.')[0])
if _shapefile_major_version < 2:
    # Adapt shapefile.Writer for the 2.0-behavior, since it is more convenient.
    class ShapefileWriter(shapefile.Writer):
        def __init__(self, path, shapeType=shapefile.NULL):
            self.path = path
            shapefile.Writer.__init__(self, shapeType)
        def __enter__(self):
            if not os.path.exists(os.path.dirname(self.path)):
                raise OSError(errno.ENOTDIR, strerror(errno.ENOTDIR), self.path)
            return self
        def __exit__(self, *exc_info):
            self.save(target=self.path)
            return False

else:
    ShapefileWriter = shapefile.Writer

X = 0
Y = 1

class PolygonParameter(object):
    def __init__(self, sopt, lopt, ty, value, variance, valhelp='', varhelp=''):
        self.sopt = sopt
        self.lopt = lopt
        self.lname = lopt.replace('-', '_')
        self.type = ty
        self.value = value
        self.variance = variance
        self.valhelp = valhelp
        self.varhelp = varhelp

    def add_value_argument(self, parser, **kwargs):
        short = parser.prefix_chars + self.sopt
        long = (2*parser.prefix_chars) + self.lopt
        if self.value is not None:
            parser.add_argument(short, long, type=self.type,
                    default=self.value, help=self.valhelp, **kwargs)

    def add_variance_argument(self, parser, **kwargs):
        short = parser.prefix_chars + self.sopt
        long = (2*parser.prefix_chars) + self.lopt
        if self.variance is not None:
            parser.add_argument(short, long, type=self.type,
                    default=self.variance, help=self.varhelp, **kwargs)

    def random_variable(self):
        return random_variable(
                self.type(self.value or 0),
                self.type(self.variance or 0),
                type=self.type)

_polyparams = [
        # short, long, type, value, variance, value_help, variance_help
    PolygonParameter('a', 'angle', float, None, 35.0,
        "Angle variance when generating directional spikes (in degrees)."
        " A smaller angle variance results in more regularly spaced directional"
        " spikes. This option has no effect; it is only used with --variance."),
    PolygonParameter('d', 'directions', int, 5, 2,
       "Number of directional spikes. Default is %(default)d."),
    PolygonParameter('n', 'vertices', int, None, 3,
        "Average number of vertices per polygon."
        " Default is twice the number of directions (from -d)."),
    PolygonParameter('r', 'inner-radius', float, 1920.0, 10.0,
        "Average radius of the inner ring. Default %(default)5.1f."),
    PolygonParameter('R', 'outer-radius', float, 1024.0, 10.0,
        "Average radius of the outer ring. Default %(default)5.1f."),
    PolygonParameter('l', 'layers', int, 1, 0,
        "Number of 'layers' for each polygon. N layers of concentric"
        " polygons are generated around each point. Default %(default)d."),
    PolygonParameter('L', 'layer_factor', float, 2.0, 0.0,
        "Additive scale factor between layers. Default %(default)5.1f."),
]

_polyparams_lookup = dict()
_polyparams_lookup.update((param.sopt, param) for param in _polyparams)
_polyparams_lookup.update((param.lopt, param) for param in _polyparams)

# Used mostly for the help message on '--variance'
_defaults = ['{0}:{1!r}'.format(param.sopt, param.variance)
        for param in _polyparams]
_default_variance_string = ', '.join(_defaults)

def parse_args(*args):
    p = argparse.ArgumentParser(
            usage="%(prog)s [OPTIONS...] [-p [POINT_FILE]] [-P [POLY_FILE]] N",
            formatter_class=argparse.RawDescriptionHelpFormatter,
            description="""\
Output polygons centered around N random points to one or more Shapefiles.
-p writes points, -P writes polygons. If neither are given, write both
to './points.*' and './polygons.*'.

Polygons are generated by drawing points on the boundary of an inner ring,
then protruding a number of 'spike' points onto the boundary of an outer ring.
The result is a star-like polygon.

Output is written in the ESRI Shapefile format, see:
    http://www.esri.com/library/whitepapers/pdfs/shapefile.pdf

The point Shapefile contains the following records:
    name            type    value
    =============================
    pointIndex     N       of point (0 to N)

The polygon Shapefile contains the following records:
    name            type    value
    =============================
    pointIndex     N       index of associated point in point file
""",
            epilog="""\
In this example:

    {prog}  --variance=d:2,r:10,R:10,n:5  -d5 -r40 -R80 -n10  15

we generate 15 polygons, each with their parameters randomly assigned in
the range shown:

    inner radius: [30, 50]
    outer radius: [70, 90]
    polygon vertices: [5, 15]
    directional spikes: [3, 7]

""")

    com = p.add_argument_group(description="Common options")

    com.add_argument('-s', '--seed', type=int, default=int(1e6*time.time()),
            help='Seed the RNG with the given integer. Default current time.')

    com.add_argument('-W', '--width', type=float, default=1920.0,
            help='Max X coordinate of any point. Default %(default)5.1f.')
    com.add_argument('-H', '--height', type=float, default=1080.0,
            help='Max X coordinate of any point. Default %(default)5.1f.')
    com.add_argument('-o', '--output', metavar='FILE', default='./shape',
            help="Write using basename FILE. Default is '%(default)s'."
            " Note that the Shapefile format specifies the creation of"
            " FILE.shp, FILE.shx, and FILE.dbf.")
    com.add_argument('-D', '--debug', action='store_true', default=False,
            help="Debug with PDB.")
    com.add_argument('-p', '--point-file', metavar='FILE', type=str, nargs='?',
            help="Generate points to FILE.{{shp,shx,dbf}}.")
    com.add_argument('-P', '--poly-file', metavar='FILE', type=str, nargs='?',
            help="Generate polygons to FILE.{{shp,shx,dbf}}.")
    com.add_argument('-g', '--graph', action='store_true', default=False,
            help="Graph points and polygons when writing them.")

    pg = p.add_argument_group('Polygon parameters')
    global _polyparams
    for param in _polyparams:
        param.add_value_argument(pg)

    pg.add_argument('-v', '--variance', type=str, default=None,
            help="""\
Variance of polygon parameters. Parameter names should be the same as the
option names above in this section (short or long) with dashes replaced by
underscores. The value given is the distance from the average to the upper and
lower boundary in the random number. (A variance of 2 and an average of 5 is
the random range [3,7]). Default string is: {0!r}
""".format(_default_variance_string))

    p.add_argument('npoints', type=int, help="Number of points to generate.")

    opts = p.parse_args(args)
    if opts.debug:
        import pdb
        pdb.set_trace()

    pv = argparse.Namespace()
    variables = argparse.Namespace()
    if opts.variance:
        # We cheat in parsing the variance by transforming the variance string
        # into an argparse-like string and making argparse... parse it.
        # The parameters are the same as above, but with different defaults.
        variance_parser = argparse.ArgumentParser(add_help=False)
        for param in _polyparams:
            param.add_variance_argument(variance_parser)

        # Convert variance string "var1:value1,..." to "-var1=value1"
        variance_args = list()
        for var_item in opts.variance.split(','):
            if len(var_item) > 1:
                var_item = (2*variance_parser.prefix_chars) + var_item
            else:
                var_item = variance_parser.prefix_chars + var_item
            variance_args.append(var_item.replace(':', '='))

        # Parse variances into a namespace with random_variables as the values.
        pv = ply.parse_args(variance_args)

    for param in _polyparams:
        if hasattr(pv, param.sopt):
            param.variance = getattr(pv, param.sopt)
        elif hasattr(pv, param.lopt):
            param.variance = getattr(pv, param.lopt)
        setattr(variables, param.lname, param.random_variable())

    opts.variables = variables

    if not opts.point_file and not opts.poly_file and not opts.graph:
        opts.point_file = './points'
        opts.poly_file = './polygons'

    return opts

def generate_points(npoints, width=800.0, height=800.0):
    return [point(random.random()*width, random.random()*height)
            for n in xrange(npoints)]

def write_points(shp, point_list):
    shp.field('pointIndex', 'N')
    for pi, (px, py) in enumerate(point_list):
        shp.point(px, py)
        shp.record(pi)

def write_poly_layers(shp, layer_list):
    shp.field('pointIndex', 'N')
    for idx, layer in enumerate(layer_list):
        write_polygons(shp, idx, layer)

def write_polygons(shp, pidx, polygon_list):
    # All our polygons only have one ring (no holes).
    for poly in polygon_list:
        shp.poly([list(poly)])
        shp.record(pidx)

class random_variable(object):
    __slots__ = ('center', 'variance', 'type')
    def __init__(self, center, variance=0.0, type=float):
        self.center = type(center)
        self.variance = type(variance)
        self.type = type
    @property
    def start(self):
        return self.center - self.variance
    @property
    def stop(self):
        return self.center + self.variance
    def __repr__(self):
        return '<random['+repr(self.start)+','+repr(self.stop)+']>'
    def __call__(self):
        return self.type(self.start + (random.random() * self.stop))

def deg2rad(degrees):
    return (degrees * math.pi) / 180.0

def make_vector(center, angle, radius):
    return point(center.x + radius * math.cos(deg2rad(angle)),
                 center.y + radius * math.sin(deg2rad(angle)))

def boundingRect(points):
    ptiter = iter(points)
    first = next(ptiter)
    # copy point objects
    mincoord = first * 1
    maxcoord = first * 1
    for pt in ptiter:
        if pt.x < mincoord.x: mincoord.x = pt.x
        if pt.y < mincoord.y: mincoord.y = pt.y
        if pt.x > maxcoord.x: maxcoord.x = pt.x
        if pt.y > maxcoord.y: maxcoord.y = pt.y
    return (mincoord, maxcoord) # bottom-left, top-right

class point(object):
    __slots__ = ('x', 'y')
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __add__(self, opt):
        if isinstance(opt, point):
            return point(self.x + opt.x, self.y + opt.y)
        return point(self.x + opt, self.y + opt)
    def __iadd__(self, opt):
        if isinstance(opt, point):
            self.x += opt.x
            self.y += opt.y
        else:
            self.x += opt
            self.y += opt
        return self
    def __sub__(self, opt):
        if isinstance(opt, point):
            return point(self.x - opt.x, self.y - opt.y)
        return point(self.x - opt, self.y - opt)
    def __isub__(self, opt):
        if isinstance(opt, point):
            self.x -= opt.x
            self.y -= opt.y
        else:
            self.x -= opt
            self.y -= opt
        return self
    def __mul__(self, scalar):
        return point(self.x * scalar, self.y * scalar)
    def __imul__(self, scalar):
        self.x *= scalar
        self.y *= scalar
        return self
    def __getitem__(self, item):
        if item == 0:
            return self.x
        if item == 1:
            return self.y
        raise IndexError("invalid item '%s'" % (repr(item),))
    def __len__(self):
        return 2
    def __contains__(self, item):
        return item == self.x or item == self.y
    def __eq__(self, opt):
        if isinstance(opt, point):
            return self.x == opt.x and self.y == opt.y
        return self.x == opt and self.y == opt
    def __str__(self):
        return '({}, {})'.format(self.x, self.y)
    def __repr__(self):
        return '<point({}, {})>'.format(self.x, self.y)

class polygon(object):
    def __init__(self, center, variables):
        self.center = center
        # Get a random number of directional spikes and total vertices
        self.nspikes = variables.directions()
        self.nvertices = max(self.nspikes+1, variables.vertices())
        # Get generators for inner/outer ring points and angle steps
        self.inner = variables.inner_radius
        self.outer = variables.outer_radius
        # Fixup the angle variable based on the number of directions.
        self.angle = variables.angle
        self.angle.center = 360. / self.nspikes
        # Generate points
        self.points = self.generate_points()
        self.bbox = boundingRect(self.points)
        self.triangles = None # list() when triangulated

    @classmethod
    def copy_of(cls, other_polygon):
        """Return a polygon which is a copy of another polygon."""
        self = polygon.__new__(cls)
        self.center = other_polygon.center
        self.points = type(other_polygon.points)(other_polygon.points)
        self.bbox = type(other_polygon.bbox)(other_polygon.bbox)
        self.triangles = None
        for varname, ov in other_polygon.__dict__.items():
            if isinstance(ov, random_variable):
                setattr(self, varname, random_variable(ov.center, ov.variance))
        return self

    def triangulate(self):
        """Triangulate the polygon."""
        from polygon_triangulate import polygon_triangulate
        self.triangles = polygon_triangulate(self.npoints, *zip(*self.points))
        return self.triangulated

    @property
    def triangulated(self):
        return self.triangles is not None
    @property
    def npoints(self):
        return len(self.points)

    def generate_points(self):
        # Store points as (angle, magnitude) for easy angle-sort.
        # When generating the points below, we choose a random magnitude near
        # the appropriate radius, separating each by a random angle.
        self.polar = list()
        # Generate inner-ring points
        angle = 0.0
        for pti in xrange(self.nvertices - self.nspikes - 1):
            self.polar.append((angle, self.inner()))
            angle = (angle + self.angle()) % 360.0
        # Generate outer-ring points
        for pti in xrange(self.nspikes):
            self.polar.append((angle, self.outer()))
            angle = (angle + self.angle()) % 360.0
        # Always end with the same point as we started with.
        if self.polar:
            self.polar.append(self.polar[0])
        # Now angle-sort and convert to cartesian points (x, y)
        # so that the returned point list represents a CW polygon.
        self.points = [make_vector(self.center, angle, radius) \
                for angle, radius
                in sorted(self.polar, key=itemgetter(0), reverse=True)]
        return self.points

    def translate(self, pt):
        """Translate all points by the given point or scalar."""
        if isinstance(pt, (tuple, list)):
            pt = point(*pt)
        self.center += pt
        self.points = [p + pt for p in self.points]
        self.bbox = boundingRect(self.points)

    def min(self, which):
        return self.bbox[0][which]
    def max(self, which):
        return self.bbox[1][which]
    @property
    def width(self):
        return self.max(X) - self.min(X)
    @property
    def height(self):
        return self.max(Y) - self.min(Y)

    def scale(self, factor):
        """Scale the polygon, anchoring at the center point."""
        for pti, pt in enumerate(self.points):
            self.points[pti] = self.center + ((pt - self.center) * factor)
        self.bbox = boundingRect(self.points)

    def adjust(self, width, height):
        """Adjust so that the entire polygon fits inside a widthxheight box."""
        # First scale the box so that it fits in WxH if necessary.
        wfactor = width / float(self.width)
        hfactor = height / float(self.height)
        fact = min(wfactor, hfactor)
        if fact < 1:
            self.scale(fact)
        # Then translate the box so it lies inside the WxH box: need 4 passes.
        for i in xrange(4):
            if self.min(X) < 0:
                self.translate((-self.min(X), 0))
                continue
            if self.max(X) > width:
                self.translate((width - self.max(X), 0))
                continue
            if self.min(Y) < 0:
                self.translate((0, -self.min(Y)))
                continue
            if self.max(Y) > height:
                self.translate((0, height - self.max(Y)))
                continue

    def layer(self, n=1, step=2.0):
        """Create and return a layer of n cocentric polygons (as lists of
        points, not polygon objects) starting with us.
        """
        # The polygon itself is the 'first layer'.
        layer = [self]
        factor = 1.0 + step
        for ln in xrange(n):
            newpoly = polygon.copy_of(self)
            newpoly.scale(factor)
            factor += step
            layer.append(newpoly)
        return layer

    def __getitem__(self, idx):
        return self.points[idx]
    def __contains__(self, pt):
        return pt in self.points
    def __len__(self):
        return len(self.points)
    def __iter__(self):
        return iter(self.points)
    def __list__(self):
        return list(self.points)

    def __repr__(self):
        return '<polygon:' + str(len(self.points)) + '>'
    def write(self, ostream):
        if self.triangulated:
            ostream.write(str(len(self.triangles)) + '\n')
            for v0, v1, v2 in self.triangles:
                ostream.write('{} {} {}\n'.format(v0, v1, v2))
        else:
            ostream.write(str(len(self.points)) + '\n')
            for px, py in self.points:
                ostream.write('{} {}\n'.format(px, py))

class file_iter(object):
    """Iterate over file objects with the given base path and extension,
    appending a file count before the extension each time next() is called.
    If maxcount is not None, stop iteration after maxcount times. Otherwise
    yield forever. If close_on_yield is True, close each file after it is
    yielded (default)."""
    def __init__(self, base, ext='', mode='w', maxcount=None, cwidth=4,
            close_on_yield=True):
        self.base = base
        self.ext = ext
        self.mode = mode
        self.count = 0
        self.cw = cwidth
        self.maxcount = maxcount
        self.close_on_yield = close_on_yield
        self.last = None
        self.generator = iter(self)
    def open(self):
        if self.close_on_yield and self.last is not None:
            self.last.close()
        self.last = open(self.name(), self.mode)
        return self.last
    def close(self):
        if self.last is not None and not self.last.closed:
            self.last.close()
    def name(self):
        name = '%s%0{}d%s'.format(self.cw) % (self.base, self.count, self.ext)
        self.count += 1
        return name
    def __iter__(self):
        i = 0
        while self.maxcount is None or i < self.maxcount:
            yield self.open()
            i += 1
        raise StopIteration
    def __del__(self):
        self.close()
    def next(self):
        return next(self.generator)

def echo_shapefiles(n, things, path):
    basename = os.path.basename(path)
    filenames = [(basename + '.' + ext) for ext in ('shp', 'shx', 'dbf')]
    dirname = os.path.dirname(path)
    print('Wrote {0} {1} to {2}/{{{3}}}'.format(
        n, things, dirname, ', '.join(filenames)))

def main(*args):
    # Parse options and args
    opts = parse_args(*args)

    def get(optname, default=0):
        return opts.get(optname, _defaults.get(optname, default))

    # Generate random points -- write them if we want.
    random.seed(opts.seed)
    points = list(generate_points(opts.npoints, opts.width, opts.height))
    if opts.point_file:
        with ShapefileWriter(opts.point_file, shapeType=shapefile.POINT) as shp:
            write_points(shp, points)
        echo_shapefiles(opts.npoints, 'points', opts.point_file)

    # Generate polygons and write them if we want.
    polygons = None
    if opts.poly_file:
        # Random variables for each polygon parameter.
        polygons = [polygon(center, opts.variables) for center in points]
        layers = [
                p.layer(opts.variables.layers(), opts.variables.layer_factor())
                for p in polygons]
        with ShapefileWriter(opts.poly_file, shapefile.POLYGON) as shp:
            write_poly_layers(shp, layers)
        echo_shapefiles(opts.npoints*opts.layers, 'polygons', opts.poly_file)

    # Graph them if we want.
    if opts.graph:
        from plotshp import pyplot, plot_points, plot_polygons
        pyplot.figure()
        plot_points(points, marker='o', markersize=3)
        if polygons:
            plot_polygons(polygons)
        pyplot.show()

    return 0

if __name__ == '__main__':
    errstr = ''
    ret = 0
    # Catch bad integer arguments
    try:
        ret = main(*sys.argv[1:])
    except ValueError as ve:
        import traceback
        traceback.print_exc()
        errstr = str(ve)

    if errstr:
        sys.stderr.write('Error: ' + str(errstr) + '\n')
        if ret == 0:
            ret = 1
    sys.exit(ret)
