#!/usr/bin/env python
#
# generate_points.py
#
# Generate some integral points in a given bounding box and write them to
# stdout.
#

import os
import sys
import time
import random
import itertools as it
import math
from operator import itemgetter
import argparse
import traceback
import shlex

import shapefile

if sys.version_info.major > 2:
    xrange = range

if sys.hexversion >= 0x3030000:
    from shlex import quote
else:
    from pipes import quote

_shapefile_major_version = int(shapefile.__version__.split('.')[0])
if _shapefile_major_version < 2:
    # Adapt shapefile.Writer for the 2.0-behavior, since it is more convenient.
    class ShapefileWriter(shapefile.Writer):
        def __init__(self, path, shapeType=shapefile.NULL):
            self.path = path
            shapefile.Writer.__init__(self, shapeType)
        def __enter__(self):
            if not os.path.exists(os.path.dirname(self.path)):
                raise OSError(errno.ENOTDIR, strerror(errno.ENOTDIR), self.path)
            return self
        def __exit__(self, *exc_info):
            self.save(target=self.path)
            return False

else:
    ShapefileWriter = shapefile.Writer

X = 0
Y = 1

class PolygonParameter(object):
    def __init__(self, sopt, lopt, ty, value, variance, valhelp='', varhelp=''):
        self.sopt = sopt
        self.lopt = lopt
        self.lname = lopt.replace('-', '_')
        self.type = ty
        self.value = value
        self.variance = variance
        self.valhelp = valhelp
        self.varhelp = varhelp

    def add_value_argument(self, parser, **kwargs):
        short = parser.prefix_chars + self.sopt
        long = (2*parser.prefix_chars) + self.lopt
        if self.value is not None:
            parser.add_argument(short, long, type=self.type,
                    default=self.value, help=self.valhelp, **kwargs)

    def add_variance_argument(self, parser, **kwargs):
        short = parser.prefix_chars + self.sopt
        long = (2*parser.prefix_chars) + self.lopt
        if self.variance is not None:
            parser.add_argument(short, long, type=self.type,
                    default=self.variance, help=self.varhelp, **kwargs)

    def random_variable(self):
        return random_variable(
                self.type(self.value or 0),
                self.type(self.variance or 0),
                type=self.type)

_polyparams = [
        # short, long, type, value, variance, value_help, variance_help
    PolygonParameter('a', 'angle', float, None, 35.0,
        "Angle variance when generating directional spikes (in degrees)."
        " A smaller angle variance results in more regularly spaced directional"
        " spikes. This option has no effect; it is only used with --variance."),
    PolygonParameter('d', 'directions', int, 5, 2,
       "Number of directional spikes. Default is %(default)d."),
    PolygonParameter('n', 'vertices', int, -1, 3,
        "Average number of vertices per polygon."
        " Default is twice the number of directions (from -d)."),
    PolygonParameter('r', 'inner-radius', float, 40.0, 5.0,
        "Average radius of the inner ring. Default %(default)5.1f."),
    PolygonParameter('R', 'outer-radius', float, 80.0, 10.0,
        "Average radius of the outer ring. Default %(default)5.1f."),
    PolygonParameter('l', 'layers', int, 1, 0,
        "Number of 'layers' for each polygon. N layers of concentric"
        " polygons are generated around each point. Default %(default)d."),
    PolygonParameter('L', 'layer_factor', float, 2.0, 0.0,
        "Additive scale factor between layers. Default %(default)5.1f."),
    PolygonParameter('T', 'ftt_factor', float, 1.0, 0.0,
        "Fixed Travel Time (FTT) between polygon layers, in minutes."
        " Default %(default)2.1f minute(s)."),
    PolygonParameter('t', 'ftt', float, 1.0, 0.0,
        "Initial Fixed Travel Time (FTT) for the first isoline, in minutes."
        " Default %(default)2.1f minute(s)."),
]

_polyparams_lookup = dict()
_polyparams_lookup.update((param.sopt, param) for param in _polyparams)
_polyparams_lookup.update((param.lopt, param) for param in _polyparams)

# Used mostly for the help message on '--variance'
_defaults = ['{0}:{1!r}'.format(param.sopt, param.variance)
        for param in _polyparams]
_default_variance_string = ','.join(_defaults)

def parse_args(*args):
    p = argparse.ArgumentParser(
        usage="%(prog)s [OPTIONS...] [-p|-u [POINT_FILE]] [-P [POLY_FILE]] N",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description="""\
Output polygons centered around N random points to one or more Shapefiles.
-p/-u writes points, -P writes polygons. If neither are given, write both
to './points.*' and './polygons.*'.
-p writes pure points (no fields), -u writes 'user' points (see below).

Polygons are generated by drawing points on the boundary of an inner ring,
then protruding a number of 'spike' points onto the boundary of an outer ring.
The result is a star-like polygon.

Output is written in the ESRI Shapefile format, see:
    http://www.esri.com/library/whitepapers/pdfs/shapefile.pdf

With -u the point Shapefile describes users, containing the following records:
    name           type        value
    ================================
    pointIndex     N (double)  index of point
    weight         N (double)  normalized weight (0-1)

The user points need not exactly represent individual persons; they should
probably be compressed to represent some "population unit" in a raster-like
field, where the weight could represent population density near the point.

The polygon Shapefile contains the following records:
    name           type        value
    ================================
    pointIndex     N (int)     index of associated point in point file
    FTT            N (double)  fixed travel time from point to ring in minutes
""",
            epilog="""\
In this example:

    {prog}  --variance=d:2,r:10,R:10,n:5  -d5 -r40 -R80 -n10  15

we generate 15 polygons, each with their parameters randomly assigned in
the range shown:

    inner radius: [30, 50]
    outer radius: [70, 90]
    polygon vertices: [5, 15]
    directional spikes: [3, 7]

""")

    com = p.add_argument_group(description="Common options")

    com.add_argument('-s', '--seed', type=int, default=int(1e6*time.time()),
            help='Seed the RNG with the given integer. Default current time.')

    com.add_argument('-x', '--min-x', type=float, default=0.0,
            help='Min X coordinate of any point. Default %(default)5.1f.')
    com.add_argument('-X', '--max-x', type=float, default=1920.0,
            help='Max X coordinate of any point. Default %(default)5.1f.')
    com.add_argument('-y', '--min-y', type=float, default=0.0,
            help='Min Y coordinate of any point. Default %(default)5.1f.')
    com.add_argument('-Y', '--max-y', type=float, default=1080.0,
            help='Max X coordinate of any point. Default %(default)5.1f.')
    com.add_argument('-o', '--output', metavar='FILE', default='./shape',
            help="Write using basename FILE. Default is '%(default)s'."
            " Note that the Shapefile format specifies the creation of"
            " FILE.shp, FILE.shx, and FILE.dbf.")
    com.add_argument('-D', '--debug', action='store_true', default=False,
            help="Debug with PDB.")
    com.add_argument('-p', '--point-file', metavar='FILE', type=str, nargs='?',
            help="Generate points to FILE.{{shp,shx,dbf}}.")
    com.add_argument('-P', '--poly-file', metavar='FILE', type=str, nargs='?',
            help="Generate polygons to FILE.{{shp,shx,dbf}}.")
    com.add_argument('-g', '--graph', action='store_true', default=False,
            help="Graph points and polygons when writing them.")

    pg = p.add_argument_group('Polygon parameters')
    global _polyparams
    for param in _polyparams:
        param.add_value_argument(pg)

    pg.add_argument('-v', '--variance', type=str, default=None,
            help="""\
Variance of polygon parameters. Parameter names should be the same as the
option names above in this section (short or long) with dashes replaced by
underscores. The value given is the distance from the average to the upper and
lower boundary in the random number. (A variance of 2 and an average of 5 is
the random range [3,7]). Default string is: {0!r}
""".format(_default_variance_string))

    p.add_argument('npoints', type=int, help="Number of points to generate.")

    opts = p.parse_args(args)
    if opts.vertices < 0:
        opts.vertices = 2 * opts.directions

    # Bounding box.
    opts.bbox = (
        ( opts.min_x, opts.max_x ),
        ( opts.min_y, opts.max_y ),
    )

    if opts.debug:
        import pdb
        pdb.set_trace()

    pv = argparse.Namespace()
    variables = argparse.Namespace()
    if opts.variance:
        # We cheat in parsing the variance by transforming the variance string
        # into an argparse-like string and making argparse... parse it.
        # The parameters are the same as above, but with different defaults.
        variance_parser = argparse.ArgumentParser(add_help=False)
        for param in _polyparams:
            param.add_variance_argument(variance_parser)

        # Convert variance string "var1:value1,..." to "-var1=value1"
        variance_args = list()
        for var_item in opts.variance.split(','):
            if len(var_item) > 1:
                var_item = (2*variance_parser.prefix_chars) + var_item
            else:
                var_item = variance_parser.prefix_chars + var_item
            variance_args.append(var_item.replace(':', '='))

        # Parse variances into a namespace with random_variables as the values.
        pv = ply.parse_args(variance_args)

    for param in _polyparams:
        # Set value from regular options.
        if hasattr(opts, param.sopt):
            param.value = getattr(opts, param.sopt)
        if hasattr(opts, param.lopt):
            param.value = getattr(opts, param.lopt)

        # Set variance from variance options.
        if hasattr(pv, param.sopt):
            param.variance = getattr(pv, param.sopt)
        elif hasattr(pv, param.lopt):
            param.variance = getattr(pv, param.lopt)
        setattr(variables, param.lname, param.random_variable())

    opts.variables = variables

    # Weight is fixed at 1.0 for now.
    opts.variables.weight = random_variable(1.0, 0.0, float)
    # This would make it uniform random:
    #opts.variables.weight = random_variable(0.5, 0.5, float)

    if not opts.point_file and not opts.poly_file and not opts.graph:
        opts.point_file = './points'
        opts.poly_file = './polygons'

    return opts

def randrangef(min_, max_):
    span = max_ - min_
    return min_ + (random.random() * span)

def generate_points(npoints, bbox):
    """Generate points in the given bounding box, which is a simple list as
    follows:
        [ [ min x , max x ],
          [ min y , max y ] ]
    """
    return [point(randrangef(bbox[X][0], bbox[X][1]),
                  randrangef(bbox[Y][0], bbox[Y][1]))
              for _ in xrange(npoints)]

def write_points(shp, point_list, opts):
    # index of this point, to associate it with a set of rings in a sister file
    shp.field('pointIndex', 'N')

    # weight (0-1) of this point; may represent a cluster of N users
    shp.field('weight', 'N')

    for pi, (px, py) in enumerate(point_list):
        shp.point(px, py)
        shp.record(pi, opts.variables.weight())

def write_poly_layers(shp, poly_layers_list, opts):
    # index associated with the pointIndex field in the associated points file
    shp.field('pointIndex', 'N')

    # fixed travel time in time units
    shp.field('FTT', 'N')

    npoly = 0
    for idx, user_layers in enumerate(poly_layers_list):
        npoly += write_polygons(shp, idx, user_layers, opts)
    return npoly # number of polygons written

def write_polygons(shp, point_idx, polygon_list, opts):
    # All our polygons only have one ring (no holes).
    ftt = opts.variables.ftt()
    for layer_idx, poly in enumerate(polygon_list):
        poly.adjust(opts.bbox)
        shp.poly([list(poly)])
        ftt += float(opts.variables.ftt_factor())
        shp.record(point_idx, ftt) # pointIndex, FTT
    return len(polygon_list) # number of polygons written

class random_variable(object):
    __slots__ = ('center', 'variance', 'type')
    def __init__(self, center, variance=0.0, type=float):
        self.center = type(center)
        self.variance = type(variance)
        self.type = type
    @property
    def start(self):
        return self.center - self.variance
    @property
    def stop(self):
        return self.center + self.variance
    def __repr__(self):
        return '<random['+repr(self.start)+','+repr(self.stop)+']>'
    def __call__(self):
        return self.type(randrangef(self.start, self.stop))

def deg2rad(degrees):
    return (degrees * math.pi) / 180.0

def make_vector(center, angle, radius):
    return point(center.x + radius * math.cos(deg2rad(angle)),
                 center.y + radius * math.sin(deg2rad(angle)))

def boundingRect(points):
    ptiter = iter(points)
    first = next(ptiter)
    # copy point objects
    mincoord = first * 1
    maxcoord = first * 1
    for pt in ptiter:
        if pt.x < mincoord.x: mincoord.x = pt.x
        if pt.y < mincoord.y: mincoord.y = pt.y
        if pt.x > maxcoord.x: maxcoord.x = pt.x
        if pt.y > maxcoord.y: maxcoord.y = pt.y
    return (
        ( mincoord.x, maxcoord.x ),
        ( mincoord.y, maxcoord.y ),
    )

class point(object):
    __slots__ = ('x', 'y')
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __add__(self, opt):
        if isinstance(opt, point):
            return point(self.x + opt.x, self.y + opt.y)
        return point(self.x + opt, self.y + opt)
    def __iadd__(self, opt):
        if isinstance(opt, point):
            self.x += opt.x
            self.y += opt.y
        else:
            self.x += opt
            self.y += opt
        return self
    def __sub__(self, opt):
        if isinstance(opt, point):
            return point(self.x - opt.x, self.y - opt.y)
        return point(self.x - opt, self.y - opt)
    def __isub__(self, opt):
        if isinstance(opt, point):
            self.x -= opt.x
            self.y -= opt.y
        else:
            self.x -= opt
            self.y -= opt
        return self
    def __mul__(self, scalar):
        return point(self.x * scalar, self.y * scalar)
    def __imul__(self, scalar):
        self.x *= scalar
        self.y *= scalar
        return self
    def __getitem__(self, item):
        if item == 0:
            return self.x
        if item == 1:
            return self.y
        raise IndexError("invalid item '%s'" % (repr(item),))
    def __len__(self):
        return 2
    def __contains__(self, item):
        return item == self.x or item == self.y
    def __eq__(self, opt):
        if isinstance(opt, point):
            return self.x == opt.x and self.y == opt.y
        return self.x == opt and self.y == opt
    def __str__(self):
        return '({}, {})'.format(self.x, self.y)
    def __repr__(self):
        return '<point({}, {})>'.format(self.x, self.y)

class polygon(object):
    @classmethod
    def copy_of(cls, other_polygon):
        """Return a polygon which is a copy of another polygon."""
        self = polygon.__new__(cls)
        self.center = other_polygon.center
        self.nspikes = other_polygon.nspikes
        self.nvertices = other_polygon.nvertices
        self.points = type(other_polygon.points)(other_polygon.points)
        self.bbox = type(other_polygon.bbox)(other_polygon.bbox)
        self.triangles = None
        self.variables = argparse.Namespace()
        for varname, ov in other_polygon.__dict__.items():
            if isinstance(ov, random_variable):
                setattr(self.variables, varname,
                        random_variable(ov.center, ov.variance))
        return self

    def __init__(self, center, variables):
        self.center = center
        # Get a random number of directional spikes and total vertices
        self.variables = variables
        self.nspikes = self.variables.directions()
        self.nvertices = max(2*self.nspikes+1, variables.vertices())
        # Fixup the angle variable based on the number of directions.
        self.angle.center = 360. / self.nspikes

        # Generate points
        self.points = self.generate_points()
        self.bbox = boundingRect(self.points)
        self.triangles = None # list() when triangulated

    @property
    def inner(self):
        return self.variables.inner_radius
    @property
    def outer(self):
        return self.variables.outer_radius
    @property
    def angle(self):
        return self.variables.angle
    @property
    def layers(self):
        return self.variables.layers
    @property
    def layer_factor(self):
        return self.variables.layer_factor

    def triangulate(self):
        """Triangulate the polygon."""
        from polygon_triangulate import polygon_triangulate
        self.triangles = polygon_triangulate(self.npoints, *zip(*self.points))
        return self.triangulated

    @property
    def triangulated(self):
        return self.triangles is not None
    @property
    def npoints(self):
        return len(self.points)

    def generate_points(self):
        # Store points as (angle, magnitude) for easy angle-sort.
        # When generating the points below, we choose a random magnitude near
        # the appropriate radius, separating each by a random angle.
        self.polar = list()
        # Generate inner-ring points
        angle = 0.0
        for pti in xrange(self.nvertices - self.nspikes - 1):
            self.polar.append((angle, self.inner()))
            angle = (angle + self.angle()) % 360.0
        # Generate outer-ring points
        for pti in xrange(self.nspikes):
            self.polar.append((angle, self.outer()))
            angle = (angle + self.angle()) % 360.0
        # Always end with the same point as we started with.
        if self.polar:
            self.polar.append(self.polar[0])
        # Now angle-sort and convert to cartesian points (x, y)
        # so that the returned point list represents a CW polygon.
        self.points = [make_vector(self.center, angle, radius) \
                for angle, radius
                in sorted(self.polar, key=itemgetter(0), reverse=True)]
        return self.points

    def _translate(self, pt):
        """Translate without recomputing the bounding box."""
        if isinstance(pt, (tuple, list)):
            pt = point(*pt)
        self.center += pt
        self.points = [p + pt for p in self.points]

    def translate(self, pt):
        """Translate all points by the given point or scalar."""
        self._translate(pt)
        self.bbox = boundingRect(self.points)

    def min(self, which):
        return self.bbox[which][0]
    def max(self, which):
        return self.bbox[which][1]

    @property
    def xmin(self):
        return self.min(X)
    @property
    def xmax(self):
        return self.max(X)
    @property
    def ymin(self):
        return self.min(Y)
    @property
    def ymax(self):
        return self.max(Y)
    @property
    def xspan(self):
        return self.max(X) - self.min(X)
    @property
    def yspan(self):
        return self.max(Y) - self.min(Y)

    def _scale(self, factor):
        """Scale the polygon without recomputing the bounding box."""
        for pti, pt in enumerate(self.points):
            self.points[pti] = self.center + ((pt - self.center) * factor)

    def scale(self, factor):
        """Scale the polygon, anchoring at the center point."""
        self._scale(factor)
        self.bbox = boundingRect(self.points)

    def adjust(self, bbox):
        """Clip vertices so that they lie in the given bounding box."""
        xmin, xmax = bbox[X]
        ymin, ymax = bbox[Y]
        for pi, pt in enumerate(self.points):
            if pt.x > xmax:
                pt.x = xmax
            elif pt.x < xmin:
                pt.x = xmin
            if pt.y > ymax:
                pt.y = ymax
            elif pt.y < ymin:
                pt.y = ymin

        self.bbox = (
            (min(self.xmin, xmin), max(self.xmax, xmax)),
            (min(self.ymin, ymin), max(self.ymax, ymax)),
        )

    def layer(self):
        """Create and return a layer of n cocentric polygons (as lists of
        points, not polygon objects) starting with us.
        """
        # The polygon itself is the 'first layer'.
        layer = [self]
        factor = 1.0 + self.layer_factor()

        # Scale and copy each remaining layer.
        nlayers = max(1, self.layers()) - 1
        for ln in xrange(nlayers):
            newpoly = polygon.copy_of(self)
            newpoly.scale(factor)
            factor += self.layer_factor()
            layer.append(newpoly)

        return layer

    def __getitem__(self, idx):
        return self.points[idx]
    def __contains__(self, pt):
        return pt in self.points
    def __len__(self):
        return len(self.points)
    def __iter__(self):
        return iter(self.points)
    def __list__(self):
        return list(self.points)

    def __repr__(self):
        return '<polygon:' + str(len(self.points)) + '>'
    def write(self, ostream):
        if self.triangulated:
            ostream.write(str(len(self.triangles)) + '\n')
            for v0, v1, v2 in self.triangles:
                ostream.write('{} {} {}\n'.format(v0, v1, v2))
        else:
            ostream.write(str(len(self.points)) + '\n')
            for px, py in self.points:
                ostream.write('{} {}\n'.format(px, py))

class file_iter(object):
    """Iterate over file objects with the given base path and extension,
    appending a file count before the extension each time next() is called.
    If maxcount is not None, stop iteration after maxcount times. Otherwise
    yield forever. If close_on_yield is True, close each file after it is
    yielded (default)."""
    def __init__(self, base, ext='', mode='w', maxcount=None, cwidth=4,
            close_on_yield=True):
        self.base = base
        self.ext = ext
        self.mode = mode
        self.count = 0
        self.cw = cwidth
        self.maxcount = maxcount
        self.close_on_yield = close_on_yield
        self.last = None
        self.generator = iter(self)
    def open(self):
        if self.close_on_yield and self.last is not None:
            self.last.close()
        self.last = open(self.name(), self.mode)
        return self.last
    def close(self):
        if self.last is not None and not self.last.closed:
            self.last.close()
    def name(self):
        name = '%s%0{}d%s'.format(self.cw) % (self.base, self.count, self.ext)
        self.count += 1
        return name
    def __iter__(self):
        i = 0
        while self.maxcount is None or i < self.maxcount:
            yield self.open()
            i += 1
        raise StopIteration
    def __del__(self):
        self.close()
    def next(self):
        return next(self.generator)

def echo_shapefiles(n, things, path):
    basename = os.path.basename(path)
    filenames = [(basename + '.' + ext) for ext in ('shp', 'shx', 'dbf')]
    dirname = os.path.dirname(path)
    print('Wrote {0} to {1}/{{{2}}}'.format(
        things, dirname, ', '.join(filenames)))
    os.system("( shputils '{0}' 2>/dev/null | tail -n +2 ) && echo"
            .format(quote(path)))

def main(*args):
    # Parse options and args
    opts = parse_args(*args)

    def get(optname, default=0):
        return opts.get(optname, _defaults.get(optname, default))

    # Generate random points -- write them if we want.
    random.seed(opts.seed)
    points = list(generate_points(opts.npoints, opts.bbox))
    if opts.point_file:
        with ShapefileWriter(opts.point_file, shapeType=shapefile.POINT) as shp:
            write_points(shp, points, opts)
        echo_shapefiles(opts.npoints, 'points', opts.point_file)

    # Generate polygons and write them if we want.
    polygons = None
    if opts.poly_file:
        # Random variables for each polygon parameter.
        polygons = [polygon(center, opts.variables) for center in points]
        # Layer parameters are taken from the random variables.
        layers = [p.layer() for p in polygons]
        npolys = 0
        with ShapefileWriter(opts.poly_file, shapefile.POLYGON) as shp:
            npolys = write_poly_layers(shp, layers, opts)
        echo_shapefiles(npolys, 'polygons', opts.poly_file)

    # Graph them if we want.
    if opts.graph:
        from plotshp import pyplot, plot_points, plot_polygons
        pyplot.figure()
        plot_points(points, marker='o', markersize=3)
        if polygons:
            plot_polygons(polygons)
        pyplot.show()

    return 0

if __name__ == '__main__':
    errstr = ''
    ret = 0
    # Catch bad integer arguments
    try:
        ret = main(*sys.argv[1:])
    except ValueError as ve:
        import traceback
        traceback.print_exc()
        errstr = str(ve)

    if errstr:
        sys.stderr.write('Error: ' + str(errstr) + '\n')
        if ret == 0:
            ret = 1
    sys.exit(ret)
