#!/usr/bin/env python
#
# generate_points.py
#
# Generate some integral points in a given bounding box and write them to
# stdout.
#

import os
import sys
import time
import random
import itertools as it
import math
from getopt import GetoptError
from operator import itemgetter

#from polygon_triangulate import polygon_triangulate
from getopt_dict import getopt_dict, make_usage, option

X = 0
Y = 1

usage = make_usage(
"""usage: {prog} [OPTIONS] [<-p,--points|-P,--polygons [POLYGON OPTIONS]>] <N>

In the default form or with -P, generate N polygons centered around N random
points according to POLYGON_OPTIONS (see below). With -p, only output points.
Polygons are generated by drawing points on the boundary of an inner ring,
then protruding a number of 'spike' points onto the boundary of an outer ring.
The result is a star-like polygon.

For polygons, the output format is:
N1
X Y
...
N2
X Y
...

Where a number N on a line by itself starts a polygon with N vertices, followed
by N lines of (X, Y) coordinates belonging to that polygon. All polygons have
one boundary and are described in counter-clockwise (CCW) order.

Common OPTIONS are:
-h,--help
    Display this help.
-s,--seed=N
    Seed the RNG with the given integer.
-W,--width=N
-H,--height=N
    Set the output dimensions. Default is 800x800. Must be given together.
-D,--debug
    Debug with pdb.
-o,--output=FILE
    Write to FILE instead of stdout.

POLYGON OPTIONS are:
-m,--multifile
    Write each polygon to a separate file. Each is suffixed by XXXX (before any
    file extension) where the Xs form the indexes of the polygons.
-g,--gnuplot
    Output 'gnuplot' commands for plotting the polygons generated into multiple
    files. Only valid with '-m'.
-w,--wait
    Flush the output stream when done and wait for input before exiting.
    Only really useful with -g probably.
-d,--directions=N
    Number of directional spikes. Default is 5.
-n,--vertices=N
    Average number of vertices per polygon. Default twice the number of
    directions.
-r,--inner-radius=N
-R,--outer-radius=N
    Average radius of the inner and outer rings. Default 40 and 80.
-t,--triangulate
    Triangulate the generated polygons and output triangles instead. The
    output format of each polygon is as follows:
    N
    v00 v01 v02
    v10 v11 v12
    ...
    Where N is the number of triangles to follow, and each line until the next
    polygon describes one triangle.
-v,--variance=param1:value1[,param2:value2[,...]]
    Variance of polygon parameters. Parameter names should be the same as the
    option names above (short or long) with no dashes. The value given is the
    distance from the average to the upper and lower boundary in the random
    number. (A variance of 2 and an average of 5 is the random range [3,7]).
    There is one additional parameter 'a' or 'angle' which controls the angle
    variance when generating directional spikes. (A smaller angle variance
    results in more regularly spaced directional spikes.) The value is in
    degrees.

    In this example:

        {prog}  --variance=d:2,r:10,R:10,n:5  -d5 -r40 -R80 -n10  15

    we generate 15 polygons, each with their parameters randomly assigned in
    the range shown:

        inner radius: [30, 50]
        outer radius: [70, 90]
        polygon vertices: [5, 15]
        directional spikes: [3, 7]
""".format(prog=sys.argv[0]))

# Common options
_common_flags = [
    ('h', 'help'),
    ('s:', 'seed='),
    ('W:', 'width='),
    ('H:', 'height='),
    ('D', 'debug'),
    ('o:', 'output='),
    ('p', 'points'),
]

# Polygon options
_polygon_flags = [
    ('P', 'polygons'),
    ('t', 'triangulate'),
    ('d:', 'directions='),
    ('n:', 'vertices='),
    ('r:', 'inner-radius='),
    ('R:', 'outer-radius='),
    ('v:', 'variance='),
    ('m', 'multifile'),
    ('w', 'wait'),
    ('g', 'gnuplot'),
]

_flags = _common_flags + _polygon_flags

_defaults = {
    'width': 800,
    'height': 800,
    'directions': 5,
    'vertices': 10,
    'inner-radius': 40,
    'outer-radius': 80,
    'multifile': False,
}

_default_variance = {
    'angle': 35,
    'directions': 2,
    'vertices': 3,
    'inner-radius': 10,
    'outer-radius': 10,
}

def generate_points(npoints, width=800, height=800):
    for pnum in xrange(npoints):
        yield point(random.randrange(width), random.randrange(height))

def write_points(ostream, ziplist):
    for px, py in ziplist:
        ostream.write('{} {}\n'.format(px, py))

def parse_variance(vstr, stol=dict(), variance=dict()):
    params = (vstr or '').split(',')
    for paramstr in params:
        if paramstr:
            if ':' not in paramstr:
                raise GetoptError("bad variance string: '%s'" % (vstr,))
            param, value = paramstr.split(':')
            variance[stol.get(param, param)] = int(value)
    return variance

class random_variable(object):
    __slots__ = ('center', 'variance')
    def __init__(self, center, variance):
        self.center = int(center)
        self.variance = int(variance)
    @property
    def start(self):
        return self.center - self.variance
    @property
    def stop(self):
        return self.center + self.variance
    def __repr__(self):
        return '<random['+repr(self.start)+','+repr(self.stop)+']>'
    def __call__(self):
        return random.randint(self.start, self.stop) # inclusive bounds

def deg2rad(degrees):
    return (degrees * math.pi) / 180.0

def make_vector(center, angle, radius):
    return point(center.x + radius * math.cos(deg2rad(angle)),
                 center.y + radius * math.sin(deg2rad(angle)))

def boundingRect(points):
    ptiter = iter(points)
    first = next(ptiter)
    # copy point objects
    mincoord = first * 1
    maxcoord = first * 1
    for pt in ptiter:
        if pt.x < mincoord.x: mincoord.x = pt.x
        if pt.y < mincoord.y: mincoord.y = pt.y
        if pt.x > maxcoord.x: maxcoord.x = pt.x
        if pt.y > maxcoord.y: maxcoord.y = pt.y
    return (mincoord, maxcoord) # bottom-left, top-right

class point(object):
    __slots__ = ('x', 'y')
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __add__(self, opt):
        if isinstance(opt, point):
            return point(self.x + opt.x, self.y + opt.y)
        return point(self.x + opt, self.y + opt)
    def __iadd__(self, opt):
        if isinstance(opt, point):
            self.x += opt.x
            self.y += opt.y
        else:
            self.x += opt
            self.y += opt
        return self
    def __sub__(self, opt):
        if isinstance(opt, point):
            return point(self.x - opt.x, self.y - opt.y)
        return point(self.x - opt, self.y - opt)
    def __isub__(self, opt):
        if isinstance(opt, point):
            self.x -= opt.x
            self.y -= opt.y
        else:
            self.x -= opt
            self.y -= opt
        return self
    def __mul__(self, scalar):
        return point(self.x * scalar, self.y * scalar)
    def __imul__(self, scalar):
        self.x *= scalar
        self.y *= scalar
        return self
    def __getitem__(self, item):
        if item == 0:
            return self.x
        if item == 1:
            return self.y
        raise IndexError("invalid item '%s'" % (repr(item),))
    def __len__(self):
        return 2
    def __contains__(self, item):
        return item == self.x or item == self.y
    def __eq__(self, opt):
        if isinstance(opt, point):
            return self.x == opt.x and self.y == opt.y
        return self.x == opt and self.y == opt
    def __str__(self):
        return '({}, {})'.format(self.x, self.y)
    def __repr__(self):
        return '<point({}, {})>'.format(self.x, self.y)

class polygon(object):
    __slots__ = ('center', 'nspikes', 'nvertices', 'inner', 'outer', 'angle',
            'points', 'bbox', 'triangles')
    def __init__(self, center, variables):
        self.center = center
        # Get a random number of directional spikes and total vertices
        self.nspikes = variables['directions']()
        self.nvertices = max(self.nspikes+1, variables['vertices']())
        # Get generators for inner/outer ring points and angle steps
        self.inner = variables['inner-radius']
        self.outer = variables['outer-radius']
        # Fixup the angle variable based on the number of directions.
        self.angle = variables['angle']
        self.angle.center = 360 // self.nspikes
        # Generate points
        self.points = self.generate_points()
        self.bbox = boundingRect(self.points)
        self.triangles = None # list() when triangulated

    def triangulate(self):
        """Triangulate the polygon."""
        from polygon_triangulate import polygon_triangulate
        self.triangles = polygon_triangulate(self.npoints, *zip(*self.points))
        return self.triangulated

    @property
    def triangulated(self):
        return self.triangles is not None
    @property
    def npoints(self):
        return len(self.points)

    def generate_points(self):
        # Store points as (angle, magnitude) for easy angle-sort.
        # When generating the points below, we choose a random magnitude near
        # the appropriate radius, separating each by a random angle.
        pointlist = []
        # Generate inner-ring points
        angle = self.angle() % 360
        for pti in xrange(self.nvertices - self.nspikes):
            pointlist.append((angle, self.inner()))
            angle = (angle + self.angle()) % 360
        # Generate outer-ring points
        for pti in xrange(self.nspikes):
            pointlist.append((angle, self.outer()))
            angle = (angle + self.angle()) % 360
        # Now angle-sort and convert to cartesian points (x, y)
        # so that the returned point list represents a CCW polygon.
        return [make_vector(self.center, angle, radius) \
                for angle, radius in sorted(pointlist, key=itemgetter(0))]

    def translate(self, pt):
        """Translate all points by the given point or scalar."""
        if isinstance(pt, (tuple, list)):
            pt = point(*pt)
        self.center += pt
        self.points = [p + pt for p in self.points]
        self.bbox = boundingRect(self.points)

    def min(self, which):
        return self.bbox[0][which]
    def max(self, which):
        return self.bbox[1][which]
    @property
    def width(self):
        return self.max(X) - self.min(X)
    @property
    def height(self):
        return self.max(Y) - self.min(Y)

    def scale(self, factor):
        """Scale the polygon, anchoring at the center point."""
        for pti, pt in enumerate(self.points):
            self.points[pti] = self.center + ((pt - self.center) * factor)
        self.bbox = boundingRect(self.points)

    def adjust(self, width, height):
        """Adjust so that the entire polygon fits inside a widthxheight box."""
        # First scale the box so that it fits in WxH if necessary.
        wfactor = width / float(self.width)
        hfactor = height / float(self.height)
        fact = min(wfactor, hfactor)
        if fact < 1:
            self.scale(fact)
        # Then translate the box so it lies inside the WxH box: need 4 passes.
        for i in xrange(4):
            if self.min(X) < 0:
                self.translate((-self.min(X), 0))
                continue
            if self.max(X) > width:
                self.translate((width - self.max(X), 0))
                continue
            if self.min(Y) < 0:
                self.translate((0, -self.min(Y)))
                continue
            if self.max(Y) > height:
                self.translate((0, height - self.max(Y)))
                continue

    def __repr__(self):
        return '<polygon:' + str(len(self.points)) + '>'
    def write(self, ostream):
        if self.triangulated:
            ostream.write(str(len(self.triangles)) + '\n')
            for v0, v1, v2 in self.triangles:
                ostream.write('{} {} {}\n'.format(v0, v1, v2))
        else:
            ostream.write(str(len(self.points)) + '\n')
            for px, py in self.points:
                ostream.write('{} {}\n'.format(px, py))

class file_iter(object):
    """Iterate over file objects with the given base path and extension,
    appending a file count before the extension each time next() is called.
    If maxcount is not None, stop iteration after maxcount times. Otherwise
    yield forever. If close_on_yield is True, close each file after it is
    yielded (default)."""
    def __init__(self, base, ext='', mode='w', maxcount=None, cwidth=4,
            close_on_yield=True):
        self.base = base
        self.ext = ext
        self.mode = mode
        self.count = 0
        self.cw = cwidth
        self.maxcount = maxcount
        self.close_on_yield = close_on_yield
        self.last = None
        self.generator = iter(self)
    def open(self):
        if self.close_on_yield and self.last is not None:
            self.last.close()
        self.last = open(self.name(), self.mode)
        return self.last
    def close(self):
        if self.last is not None and not self.last.closed:
            self.last.close()
    def name(self):
        name = '%s%0{}d%s'.format(self.cw) % (self.base, self.count, self.ext)
        self.count += 1
        return name
    def __iter__(self):
        i = 0
        while self.maxcount is None or i < self.maxcount:
            yield self.open()
            i += 1
        raise StopIteration
    def __del__(self):
        self.close()
    def next(self):
        return next(self.generator)

def main(*args):
    # Parse options and args
    global _flags
    sopts = tuple(pair[0] for pair in _flags)
    lopts = tuple(pair[1] for pair in _flags)
    stol = dict([(option(s, True).name, option(l, False).name)
                for s, l in zip(sopts, lopts)])
    opts, args = getopt_dict(args, sopts, lopts, stol)

    if 'help' in opts:
        usage()

    if len(args) != 1:
        usage('Wrong number of arguments.')

    def get(optname, default=0):
        return opts.get(optname, _defaults.get(optname, default))

    if 'debug' in opts:
        import pdb
        pdb.set_trace()

    seed = int(opts.get('seed', time.time()*1e6))
    width = int(get('width'))
    height = int(get('height'))
    npoints = int(args[0])
    variance = parse_variance(opts.get('variance'), stol,  _default_variance)
    output = opts.get('output', '/dev/stdout')

    random.seed(seed)
    points = list(generate_points(npoints, width, height))
    common_opts = [option(l).name for l in zip(*_common_flags)[1]]
    if 'points' in opts:
        if 'polygons' in opts:
            usage('--points and --polygons are mutually exclusive')
        for optname in opts.keys():
            if optname not in common_opts:
                usage('--%s is not valid with --points' % (optname,))
        write_points(sys.stdout, points)
        return 0

    # Get output file. We use a special iterator to yield one file per polygon
    # when -m is given. Otherwise use the given output file or stdout.
    multifile = bool(opts.get('multifile'))
    if 'output' in opts:
        output = opts['output']
        if multifile:
            path, ext = os.path.splitext(output)
            fileiter = file_iter(path, ext, 'w')
        else:
            fileiter = it.repeat(open(output, 'w'))
    else:
        if multifile:
            usage('-m cannot be given without -o')
        fileiter = it.repeat(sys.stdout)

    gnuplot = bool(opts.get('gnuplot'))
    wait = bool(opts.get('wait'))
    if gnuplot and not multifile:
        usage('-g is only valid with -m')
    if wait and not gnuplot:
        usage('-w is only valid with -g')

    # Random variables for each polygon parameter.
    randvars = dict((opt,
        random_variable(opts.get(opt, _defaults.get(opt, 0)), variance[opt]))
        for opt in variance.keys())
    # Add the angle variable - the center will actually be fixed when the
    # number of directional spikes is known.
    randvars['angle'] = random_variable(0, variance['angle'])
    global polygon
    polygons = [polygon(center, randvars) for center in points]

    # See if we want to triangulate the polygons first.
    triangulate = opts.get('triangulate', False)
    for poly in (polygons if triangulate else []):
        poly.triangulate()

    # Now output polygons. Adjust them first so they don't leave our bounds.
    # If we are using multifile, also output a line which can be used to
    # plot the polygons in gnuplot.
    if gnuplot:
        sys.stdout.write('plot ')
    for polyi, polygon in enumerate(polygons):
        polygon.adjust(width, height)
        ofile = next(fileiter)
        polygon.write(ofile)
        ofile.flush()
        if gnuplot:
            sys.stdout.write('"%s" using 1:2 title "poly.%d" with lines'
                    % (ofile.name, polyi))
            if polyi != len(polygons) - 1:
                sys.stdout.write(', ')
    ofile.close()
    if gnuplot:
        sys.stdout.write('\n')
        sys.stdout.flush()
        # If we're piped, wait for input to let following program go
        if wait:
            if not sys.stdout.isatty():
                raw_input()

    return 0

if __name__ == '__main__':
    errstr = ''
    ret = 0
    # Catch bad integer arguments
    try:
        ret = main(*sys.argv[1:])
    except ValueError as ve:
        import traceback
        traceback.print_exc()
        errstr = str(ve)
    except GetoptError as ue:
        usage(str(ue))

    if errstr:
        sys.stderr.write('Error: ' + str(errstr) + '\n')
        if ret == 0:
            ret = 1
    sys.exit(ret)
